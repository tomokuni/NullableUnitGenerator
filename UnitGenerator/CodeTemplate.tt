<#@ template debug="false" hostspecific="false" language="C#" linePragmas="false" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY NullableUnitGenerator. DO NOT CHANGE IT.
// </auto-generated>
#pragma warning disable IDE0079 // 不要な抑制を削除します
#pragma warning disable CS8669  // Null 許容参照型の注釈は、'#nullable' 注釈のコンテキスト内のコードでのみ使用する必要があります。自動生成されたコードには、ソースに明示的な '#nullable' ディレクティブが必要です。
#pragma warning disable CS8632	// '#nullable' 注釈コンテキスト内のコードでのみ、Null 許容参照型の注釈を使用する必要があります。
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Reflection;
<# if (HasFlag(UnitGenerateOption.JsonConverter)) { #>
using System.Text.Json;
using System.Text.Json.Serialization;
<# } #>
<# if (HasFlag(UnitGenerateOption.DapperTypeHandler)) { #>
#if !UGO_DAPPER_DISABLE
using System.Runtime.CompilerServices;
#endif
<# } #>
<# if (HasFlag(UnitGenerateOption.MessagePackFormatter)) { #>
#if !UGO_MESSAGEPACK_DISABLE
using MessagePack;
using MessagePack.Formatters;
#endif
<# } #>

using NullableUnitGenerator;

<# if (!string.IsNullOrEmpty(Namespace)) { #>
namespace <#= Namespace #>;
<# } #>


/// <summary>
/// <#= Name #> is ValueObject that support Null and Empty(Undefind) values.<br/>
/// <#= Name #> は Null と Empty(Unddefind) 値をサポートする ValueObject です。<br/><br/>
/// Primitive type is <#= TypeName #> (<#= TypeNameFull #>)
/// </summary>
<# if (HasFlag(UnitGenerateOption.MessagePackFormatter)) { #>
#if !UGO_MESSAGEPACK_DISABLE
[MessagePackFormatter(typeof(<#= Name #>MessagePackFormatter))]
#endif
<# } #>
<# if (HasFlag(UnitGenerateOption.JsonConverter)) { #>
[JsonConverter(typeof(<#= Name #>JsonConverter))]
<# } #>
[System.ComponentModel.TypeConverter(typeof(<#= Name #>TypeConverter))]
public readonly partial struct <#= Name #> : IUnitOf, IUnitOf<<#= Name #>, <#= TypeName #>>, IEquatable<<#= Name #>>, IEqualityComparer<<#= Name #>> <#= HasFlag(UnitGenerateOption.IComparable) && HasCompareToMethod ? $", IComparable<{Name}>" : "" #>, IValidatableObject
{
    // Namespace : <#= Namespace ?? "(null)" #>
    // Name      : <#= Name #>
    // UnitGenerateOption : <#= Options #>
    // ToStringFormat      : <#= ToStringFormat ?? "(null)" #>
    //
    // TypeName         : <#= TypeName ?? "(null)" #>
    // TypeNameFull     : <#= TypeNameFull ?? "(null)" #>
    // TypeNameNullable : <#= TypeNameNullable ?? "(null)" #>
    // MetadataTypeName : <#= MetadataTypeName ?? "(null)" #>
    // IsValueType : <#= IsValueType #>
    // IsArray     : <#= IsArray #>
    // IsUlid      : <#= IsUlid #>
    // HasArithmeticIncDecOperator    : <#= HasArithmeticIncDecOperator #>
    // HasArithmeticAddSubOperator    : <#= HasArithmeticAddSubOperator #>
    // HasArithmeticMulDevModOperator : <#= HasArithmeticMulDevModOperator #>
    // HasComparisonOperator          : <#= HasComparisonOperator #>
    // HasParseMethod     : <#= HasParseMethod #>
    // HasCompareToMethod : <#= HasCompareToMethod #>
    // HasMinMaxMethod    : <#= HasMinMaxMethod #>
    // IsBuiltinIntegralType : <#= IsBuiltinIntegralType #>
    // IsBuiltinFloatingType : <#= IsBuiltinFloatingType #>
    // IsBuiltinNumericType  : <#= IsBuiltinNumericType #>
    // IsSupportUtf8Formatter() : <#= IsSupportUtf8Formatter() #>
    // GetDbType() : <#= "DbType." + GetDbType().ToString() #>
    //
    // <#= TypeName #> support method
    //   <#= OperatorsString ?? "(null)" #>
    //
    // ITypeSymbol Info
<# foreach(var k in DicTypeName.Keys){ #>
    //   <#= DicTypeName[k] #>
<# } #>


    //
    // backing field
    //

    private readonly <#= TypeName #> _value = default;
    private readonly UnitState _state = UnitState.Undef;


    //
    // Constructor
    //

    /// <summary>Complete Constructor</summary>
    public <#= Name #>()
    { }

    /// <summary>Complete Constructor</summary>
    public <#= Name #>(in <#= Name #> value)
    {
        (_state, _value) = (value._state, value._value);

        ValidateInConstructor();
    }

    /// <summary>Complete Constructor</summary>
    public <#= Name #>(in UnitState state, in <#= TypeName #> value = default)
    {
        (_state, _value) = (state, value) switch
        {
            (UnitState.Undef, _) => (state, default),
            (UnitState.Null, _) => (state, default),
<# if (!IsValueType) { #>
            (_, null) => (state, default),
<# } #>
            _ => (state, value)
        };

        ValidateInConstructor();
    }

<# if (IsValueType) { #>
    /// <summary>Complete Constructor</summary>
    public <#= Name #>(in <#= TypeName #> value)
    {
        (_state, _value) = (UnitState.Value, value);

        ValidateInConstructor();
    }
<# } #>

    /// <summary>Complete Constructor</summary>
    public <#= Name #>(in <#= TypeNameNullable #> value)
    {
        (_state, _value) = value switch
        {
            null => (UnitState.Null, default),
            _ => (UnitState.Value, (<#= TypeName #>)value),
        };

        ValidateInConstructor();
    }


    //
    // static define
    //

    /// <summary>Display string as Undef.</summary>
    public static readonly string sUndef = $"({UnitState.Undef})";

    /// <summary>Display string as Null.</summary>
    public static readonly string sNull = $"({UnitState.Null})";

<#if (IsBuiltinNumericType) { #>

    //
    // MaxValue, MinValue
    //

    /// <summary>Represents the largest possible value. This field is constant.</summary>
    public static readonly  <#= TypeName #> MaxValue = <#= TypeName #>.MaxValue;

    /// <summary>Represents the smallest possible value. This field is constant.</summary>
    public static readonly  <#= TypeName #> MinValue = <#= TypeName #>.MinValue;

<# } #>

    //
    // static property
    //

    /// <summary>UnitOfAttribute instance.</summary>
    public static UnitOfAttribute UnitOfAttribute { get; }
        = typeof(<#= Name #>).GetCustomAttributes<UnitOfAttribute>().SingleOrDefault();

    /// <summary>UnitOfSchemaAttribute instance.</summary>
    public static UnitOfSchemaAttribute UnitOfSchemaAttribute { get; }
        = typeof(<#= Name #>).GetCustomAttributes<UnitOfSchemaAttribute>().SingleOrDefault();
        
    /// <summary>Undefined value instance.</summary>
    public static <#= Name #> UndefValue { get; } = new(UnitState.Undef, default);

    /// <summary>Null value instance.</summary>
    public static <#= Name #> NullValue { get; } = new(UnitState.Null, default);

    /// <summary>Value state default value instance.</summary>
    public static <#= Name #> DefaultValueOfValueState   { get; } = new(UnitState.Value, default);


    /// <summary>base type.</summary>
    public static Type BaseType { get; } = typeof(<#= TypeName #>);

    /// <summary>Is base type nullable?</summary>
    public static bool IsNullable { get; }
        = !BaseType.IsValueType                             // 値型でない -> Nullable
        || Nullable.GetUnderlyingType(BaseType) != null;    // 非Null許容型が取得できる -> Null許容演算子が指定されている -> Nullable


    //
    // static method
    //

    /// <summary>Determines if either value is undefined or null.</summary>
    /// <returns>
    /// Return Value – Description<br/>
    /// <b>UnitState.Undef</b> – if either value is undefined.<br/>
    /// <b>UnitState.Null</b> – if either value is null.<br/>
    /// <b>UnitState.Value</b> – if either value is set.
    /// </returns>
    public static UnitState CheckState(in <#= Name #> x, in <#= Name #> y, out <#= Name #> result)
    {
        var (state, outVal) = (x, y) switch
        {
            { x.IsUndef: true } => (UnitState.Undef, <#= Name #>.UndefValue),
            { y.IsUndef: true } => (UnitState.Undef, <#= Name #>.UndefValue),
            { x.IsNull: true } => (UnitState.Null, <#= Name #>.NullValue),
            { y.IsNull: true } => (UnitState.Null, <#= Name #>.NullValue),
            _ => (UnitState.Value, <#= Name #>.DefaultValueOfValueState  ),
        };
        result = outVal;
        return state;
    }

    /// <summary>Determine if a value is undefined or null.</summary>
    /// <returns>
    /// Return Value – Description<br/>
    /// <b>UnitState.Undef</b> – if value is undefined.<br/>
    /// <b>UnitState.Null</b> – if value is null.<br/>
    /// <b>UnitState.Value</b> – if value is set.
    /// </returns>
    public static UnitState CheckState(in <#= Name #> x, out <#= Name #> result)
    {
        var (state, outVal) = x switch
        {
            { IsUndef: true } => (UnitState.Undef, <#= Name #>.UndefValue),
            { IsNull: true } => (UnitState.Null, <#= Name #>.NullValue),
            _ => (UnitState.Value, <#= Name #>.DefaultValueOfValueState  ),
        };
        result = outVal;
        return state;
    }


    //
    // get state
    //

    /// <summary><see langword="true"/> if undefined; otherwise.</summary>
    /// <returns><b><see langword="true"/></b> : if undefined</returns>
    public bool IsUndef
        => _state == UnitState.Undef;

    /// <summary><see langword="true"/> if null; otherwise.</summary>
    /// <returns><b><see langword="true"/></b> : if null</returns>
    public bool IsNull
        => _state == UnitState.Null;

    /// <summary><see langword="true"/> if undefined or null; otherwise.</summary>
    /// <returns><b><see langword="true"/></b> : if null or undefined</returns>
    public bool IsUndefOrNull
        => _state != UnitState.Value;

    /// <summary><see langword="true"/> if null or hasValue; otherwise.</summary>
    /// <returns><b><see langword="true"/></b> : if null or hasValue</returns>
    public bool IsNullOrHasValue
        => _state != UnitState.Undef;

    /// <summary><see langword="true"/> if not undefined and not null; otherwise.</summary>
    /// <returns><b><see langword="true"/></b> : if hasValuel</returns>
    public bool HasValue
        => _state == UnitState.Value;

    /// <summary>return value state.</summary>
    /// <returns>
    /// <b>Undef</b><br/>
    /// <b>Null</b><br/>
    /// <b>Value</b>
    /// </returns>
    public UnitState State
        => _state;


    //
    // get value
    //

    /// <summary>return value if HasValue is true; otherwise, throw InvalidOperationException()</summary>
    /// <returns>
    /// <b>value</b> : if HasValue is true<br/>
    /// <b>throw InvalidOperationException("Value is Null.")</b> : if IsNull is true<br/>
    /// <b>throw InvalidOperationException("Value is Undef.")</b> : if IsUndef is true
    /// </returns>
    public <#= TypeName #> Value
        => (_state, _value) switch
        {
            (UnitState.Value, _) => _value,
            (UnitState.Null, _) => throw new InvalidOperationException($"Value is {UnitState.Null}."),
            _ => throw new InvalidOperationException($"Value is {UnitState.Undef}."),
        };
        
        
    /// <inheritdoc cref="Value" />
    public <#= TypeName #> GetOrThrow()
        => Value;

    /// <summary>return value if HasValue is Value; otherwise, null</summary>
    /// <returns>
    /// <b>value</b> : if assigned and not null<br/>
    /// <b>null</b> : otherwise
    /// </returns>
    public <#= TypeNameNullable #> GetOrNull()
        => HasValue ? _value : null;
        
    /// <summary>return value if HasValue is Value; otherwise, default</summary>
    /// <returns>
    /// <b>value</b> : if assigned and not null<br/>
    /// <b>default</b> : otherwise
    /// </returns>
    public <#= TypeName #> GetOrDefault()
        => HasValue ? _value : default;
                
    /// <summary>return value if HasValue is Value; otherwise, default</summary>
    /// <returns>
    /// <b>value</b> : if assigned and not null<br/>
    /// <b>default</b> : otherwise
    /// </returns>
    public object GetOrDefaultAsObject()
        => HasValue ? _value : default;
        

    /// <summary>return value if HasValue is Value; otherwise, defaultValue</summary>
    /// <returns>
    /// <b>value</b> : if assigned and not null<br/>
    /// <b>defaultValue</b> : otherwise
    /// </returns>
    public <#= TypeName #> GetOr(in <#= TypeName #> defaultValue)
        => HasValue ? _value : defaultValue;

<# if (IsValueType) { #>
    /// <inheritdoc cref="GetOr(in <#= TypeName #>)" />
    public <#= TypeNameNullable #> GetOr(in <#= TypeNameNullable #> defaultValue)
        => HasValue ? _value : defaultValue;
<# } #>


    /// <summary>return true and out parameter value if HasValue is true; otherwise, false.</summary>
    /// <param name="value">value</param>
    /// <param name="defaultValue">defaultValue</param>
    /// <returns><b><see langword="true"/> and out parameter value</b> : if HasValue is true,</returns>
    public bool TryGet(out <#= TypeName #> value, in <#= TypeName #> defaultValue = default)
    {
        value = HasValue ? _value : defaultValue;
        return HasValue;
    }
    
<# if (IsValueType) { #>
    /// <inheritdoc cref="TryGet(out <#= TypeName #>, in <#= TypeName #>)" />
    public bool TryGet(out <#= TypeNameNullable #> value, in <#= TypeNameNullable #> defaultValue = null)
    {
        value = (<#= TypeNameNullable #>)(HasValue ? _value : defaultValue);
        return HasValue;
    }
<# } #>


    //
    // GetHashCode
    //

    /// <inheritdoc/>
    public override int GetHashCode()
        => EqualityComparer<UnitState>.Default.GetHashCode(_state) * -1521134295
         + EqualityComparer<<#= TypeName #>>.Default.GetHashCode(_value);

    /// <inheritdoc/>
    public int GetHashCode(<#= Name #> obj)
        => obj.GetHashCode();


    //
    // ToString
    //

    /// <summary>Returns this instance of System.String; no actual conversion is performed.</summary>
    /// <returns>The current string.</returns>
    public override string ToString()
<# if (ToStringFormat == null) { #>
        => HasValue ? $"{_value}" : (IsNull ? sNull : sUndef);
<# } else { #>
        => HasValue ? string.Format("<#= ToStringFormat #>", _value) : (IsNull ? sNull : sUndef);
<# } #>

    /// <summary>Returns this instance of System.String with the conversion specified by format.</summary>
    /// <returns>The specified string value.</returns>
    public string ToString(string format)
        => HasValue ? ((dynamic)_value).ToString(format) : (IsNull ? sNull : sUndef);


    //
    // Validate
    //

    /// <summary>ValidateInConstructor</summary>
    partial void ValidateInConstructor();

    /// <summary>Validate</summary>
    public IEnumerable<ValidationResult> Validate(ValidationContext validationContext)
    {
        if (!HasValue)
            return Enumerable.Empty<ValidationResult>();
        if (UnitOfSchemaAttribute is null)
            return Enumerable.Empty<ValidationResult>();

        // Validationを実施
        return UnitValidate.ValidateObject(GetOrDefault(), UnitOfSchemaAttribute, validationContext);
    }

<# if (TypeName == "Guid" || TypeName == "System.Guid") { #>

    //
    // Guid
    //

    /// <summary>NewGuid</summary>
    /// <returns>Guid.NewGuid()</returns>
    public static <#= Name #> New()
        => new <#= Name #>(Guid.NewGuid());

    /// <inheritdoc cref="New()" />
    public static <#= Name #> New<#= Name #>()
        => new <#= Name #>(Guid.NewGuid());

<# } #>
<# if (TypeName == "Ulid" || TypeName == "System.Ulid") { #>

    //
    // Ulid
    //

    /// <summary>NewUlid</summary>
    /// <returns>Ulid.NewUlid()</returns>
    public static <#= Name #> New()
        => new <#= Name #>(Ulid.NewUlid());

    /// <inheritdoc cref="New()" />
    public static <#= Name #> New<#= Name #>()
        => new <#= Name #>(Ulid.NewUlid());

<# } #>
<# if (TypeName == "bool") { #>

    //
    // bool operator
    //

    /// <summary>operator true</summary>
    public static <#= TypeName #> operator true(<#= Name #> x)
        => x.HasValue
           ? x._value
           : x.IsUndef ? UndefValue : NullValue;

    /// <summary>operator false</summary>
    public static <#= TypeName #> operator false(<#= Name #> x)
        => x.HasValue
           ? !x._value
           : x.IsUndef ? UndefValue : NullValue;

    /// <summary>operator !</summary>
    public static <#= TypeName #> operator !(<#= Name #> x)
        => x.HasValue
           ? !x._value
           : x.IsUndef ? UndefValue : NullValue;

<# } #>

    //
    // implicit, explicit operator    // UnitGenerateOption.ImplicitOperator or Unspecified
    //

<# if (HasFlag(UnitGenerateOption.ImplicitOperator)) { #>
    /// <summary>implicit(暗黙的) operator</summary>
    public static implicit operator <#= TypeName #>(in <#= Name #> value)
        => (<#= TypeName #>)value.GetOrThrow();

    /// <summary>implicit(暗黙的) operator</summary>
    /// <returns><#= Name #> value.</returns>
    public static implicit operator <#= Name #>(in <#= TypeName #> value)
        => new(value);

<# if (IsValueType) { #>
    /// <summary>implicit(暗黙的) operator</summary>
    /// <returns><#= TypeNameNullable #> value.</returns>
    public static implicit operator <#= TypeNameNullable #>(in <#= Name #> value)
        => (<#= TypeNameNullable #>)value.GetOr(null);

    /// <summary>implicit(暗黙的) operator</summary>
    /// <returns><#= Name #> value.</returns>
    public static implicit operator <#= Name #>(in <#= TypeNameNullable #> value)
        => new(value);
<# } #>
<# } else { #>
    /// <summary>explicit(明示的) operator</summary>
    public static explicit operator <#= TypeName #>(in <#= Name #> value)
        => (<#= TypeName #>)value.GetOrThrow();

    /// <summary>explicit(明示的) operator</summary>
    /// <returns><#= Name #> value.</returns>
    public static explicit operator <#= Name #>(in <#= TypeName #> value)
        => new(value);

<# if (IsValueType) { #>
    /// <summary>explicit(明示的) operator</summary>
    /// <returns><#= TypeNameNullable #> value.</returns>
    public static explicit operator <#= TypeNameNullable #>(in <#= Name #> value)
        => (<#= TypeNameNullable #>)value.GetOr(null);

    /// <summary>explicit(明示的) operator</summary>
    /// <returns><#= Name #> value.</returns>
    public static explicit operator <#= Name #>(in <#= TypeNameNullable #> value)
        => new(value);
<# } #>
<# } #>


    //
    // Equals, IEquatable<<#= Name #>>
    //

    /// <inheritdoc/>
    public bool Equals(<#= Name #> other)
        => EqualityComparer<UnitState>.Default.Equals(_state, other._state)
        && EqualityComparer<<#= TypeName #>>.Default.Equals(_value, other._value);

    /// <inheritdoc/>
    public bool Equals(<#= Name #> left, <#= Name #> right)
        => left.Equals(right);

    /// <inheritdoc/>
    public override bool Equals(object? obj)
        => obj is <#= Name #> uo && Equals(uo);


    //
    // ==, != operator
    //

    /// <summary>Returns a value indicating whether two instances are same value.</summary>
    /// <returns>true if other has the same value as this instance; otherwise, false.</returns>
    public static bool operator ==(in <#= Name #> left, in <#= Name #> right)
        => left.Equals(right);

    /// <summary>Returns a value indicates whether two instances are different values.</summary>
    /// <returns>true if other has the same value as this instance; otherwise, false.</returns>
    public static bool operator !=(in <#= Name #> left, in <#= Name #> right)
        => !(left == right);


    //
    // CompareTo, IComparable<<#= Name #>>    // UnitGenerateOption.IComparable
    //
<# if (HasFlag(UnitGenerateOption.IComparable)) { #>

<# if (HasCompareToMethod) { #>
    /// <summary>Compares this instance to a specified <#= Name #> and returns an indication of their relative values.</summary>
    /// <returns>
    /// A signed number indicating the relative values of this instance and value.<br/>
    /// <b>Return Value</b> – Description<br/>
    /// <b>Less than zero</b> – This instance is less than value.<br/>
    /// <b>Zero</b> – This instance is equal to value.<br/>
    /// <b>Greater than zero</b> – This instance is greater than value.
    /// </returns>
    public int CompareTo(<#= Name #> other)
        => HasValue && other.HasValue
           ? _value.CompareTo(other._value)
           : 0;
<# } else { #>
        // <#= TypeName #> is types that do not support method CompareTo
<# } #>
<# } else { #>
        // No option specified
<# } #>


    //
    // >, <, >=, <= operator    // UnitGenerateOption.ComparisonOperator
    //
<# if (HasFlag(UnitGenerateOption.ComparisonOperator)) { #>

<# if (HasComparisonOperator) { #>
    /// <summary>operator &gt; (GreaterThan)</summary>
    public static bool operator >(in <#= Name #> x, in <#= Name #> y)
        => x.HasValue && y.HasValue
           ? x._value > y._value
           : false;

    /// <summary>operator &lt; (LessThan)</summary>
    public static bool operator <(in <#= Name #> x, in <#= Name #> y)
        => x.HasValue && y.HasValue
           ? x._value < y._value
           : false;

    /// <summary>operator &gt;= (GreaterThanOrEqual)</summary>
    public static bool operator >=(in <#= Name #> x, in <#= Name #> y)
        => x.HasValue && y.HasValue
           ? x._value >= y._value
           : false;

    /// <summary>operator &lt;= (LessThanOrEqual)</summary>
    public static bool operator <=(in <#= Name #> x, in <#= Name #> y)
        => x.HasValue && y.HasValue
           ? x._value <= y._value
           : false;
<# } else { #>
        // <#= TypeName #> is types that do not support operater > (GreaterThan)
        // <#= TypeName #> is types that do not support operater < (LessThan)
        // <#= TypeName #> is types that do not support operater >= (GreaterThanOrEqual)
        // <#= TypeName #> is types that do not support operater <= (LessThanOrEqual)
<# } #>
<# } else { #>
        // No option specified
<# } #>


    //
    // +, -, *, /, % operator    UnitGenerateOption.ArithmeticOperator
    //
<# if (HasFlag(UnitGenerateOption.ArithmeticOperator)) { #>

<# if (HasArithmeticAddSubOperator) { #>
    /// <summary>operator + (Addition)</summary>
    public static <#= Name #> operator +(in <#= Name #> x, in <#= Name #> y)
        => x.HasValue && y.HasValue
           ? new <#= Name #>(checked ((<#= TypeName #>)(x._value + y._value)))
           : (x.IsUndef || y.IsUndef) ? UndefValue : NullValue;

    /// <summary>operator - (Subtraction)</summary>
    public static <#= Name #> operator -(in <#= Name #> x, in <#= Name #> y)
        => x.HasValue && y.HasValue
           ? new <#= Name #>(checked ((<#= TypeName #>)(x._value - y._value)))
           : (x.IsUndef || y.IsUndef) ? UndefValue : NullValue;
<# } else { #>
        // <#= TypeName #> is types that do not support operater + (Addition)
        // <#= TypeName #> is types that do not support operater - (Subtraction)
<# } #>

<# if (HasArithmeticMulDevModOperator) { #>
    /// <summary>operator * (Multiply)</summary>
    public static <#= Name #> operator *(in <#= Name #> x, in <#= Name #> y)
        => x.HasValue && y.HasValue
           ? new <#= Name #>(checked ((<#= TypeName #>)(x._value * y._value)))
           : (x.IsUndef || y.IsUndef) ? UndefValue : NullValue;

    /// <summary>operator / (Division)</summary>
    public static <#= Name #> operator /(in <#= Name #> x, in <#= Name #> y)
        => x.HasValue && y.HasValue
           ? new <#= Name #>(checked ((<#= TypeName #>)(x._value / y._value)))
           : (x.IsUndef || y.IsUndef) ? UndefValue : NullValue;

    /// <summary>operator % (Modulus)</summary>
    public static <#= Name #> operator %(in <#= Name #> x, in <#= Name #> y)
        => x.HasValue && y.HasValue
           ? new <#= Name #>(checked ((<#= TypeName #>)(x._value % y._value)))
           : (x.IsUndef || y.IsUndef) ? UndefValue : NullValue;
<# } else { #>
        // <#= TypeName #> is types that do not support operater * (Multiply)
        // <#= TypeName #> is types that do not support operater / (Division)
        // <#= TypeName #> is types that do not support operater % (Modulus)
<# } #>
<# } else { #>
        // No option specified
<# } #>


    //
    // ++, --, +, -, *, /, % operator    UnitGenerateOption.ValueArithmeticOperator
    //
<# if (HasFlag(UnitGenerateOption.ValueArithmeticOperator)) { #>

<# if (HasArithmeticIncDecOperator) { #>
    /// <summary>operator ++ (Increment)</summary>
    public static <#= Name #> operator ++(in <#= Name #> x)
        => x.HasValue
           ? new <#= Name #>(checked ((<#= TypeName #>)(x._value + 1)))
           : x.IsUndef ? UndefValue : NullValue;

    /// <summary>operator -- (Decrement)</summary>
    public static <#= Name #> operator --(in <#= Name #> x)
        => x.HasValue
           ? new <#= Name #>(checked ((<#= TypeName #>)(x._value - 1)))
           : x.IsUndef ? UndefValue : NullValue;
<# } else { #>
        // <#= TypeName #> is types that do not support operater ++ (Increment)
        // <#= TypeName #> is types that do not support operater -- (Decrement)
<# } #>

<# if (HasArithmeticAddSubOperator) { #>
    /// <summary>operator + (Addition)</summary>
    public static <#= Name #> operator +(in <#= Name #> x, in <#= TypeName #> y)
        => x.HasValue
           ? new <#= Name #>(checked ((<#= TypeName #>)(x._value + y)))
           : x.IsUndef ? UndefValue : NullValue;

    /// <summary>operator - (Subtraction)</summary>
    public static <#= Name #> operator -(in <#= Name #> x, in <#= TypeName #> y)
        => x.HasValue
           ? new <#= Name #>(checked ((<#= TypeName #>)(x._value - y)))
           : x.IsUndef ? UndefValue : NullValue;
<# } else { #>
        // <#= TypeName #> is types that do not support operater + (Addition)
        // <#= TypeName #> is types that do not support operater - (Subtraction)
<# } #>

<# if (HasArithmeticMulDevModOperator) { #>
    /// <summary>operator * (Multiply)</summary>
    public static <#= Name #> operator *(in <#= Name #> x, in <#= TypeName #> y)
        => x.HasValue
           ? new <#= Name #>(checked ((<#= TypeName #>)(x._value * y)))
           : x.IsUndef ? UndefValue : NullValue;

    /// <summary>operator / (Division)</summary>
    public static <#= Name #> operator /(in <#= Name #> x, in <#= TypeName #> y)
        => x.HasValue
           ? new <#= Name #>(checked ((<#= TypeName #>)(x._value / y)))
           : x.IsUndef ? UndefValue : NullValue;

    /// <summary>operator % (Modulus)</summary>
    public static <#= Name #> operator %(in <#= Name #> x, in <#= TypeName #> y)
        => x.HasValue
           ? new <#= Name #>(checked ((<#= TypeName #>)(x._value % y)))
           : x.IsUndef ? UndefValue : NullValue;
<# } else { #>
        // <#= TypeName #> is types that do not support operater * (Multiply)
        // <#= TypeName #> is types that do not support operater / (Division)
        // <#= TypeName #> is types that do not support operater % (Modulus)
<# } #>
<# } else { #>
        // No option specified
<# } #>


    //
    // Parse, TryParse    // UnitGenerateOption.ParseMethod
    //
<# if (HasFlag(UnitGenerateOption.ParseMethod)) { #>

<# if (HasParseMethod) { #>
    /// <summary>Converts the string representation of a number.</summary>
    /// <returns>A equivalent to the number contained in s.</returns>
    /// <exception cref="System.ArgumentNullException" >s is null.</exception>
    /// <exception cref="System.FormatException" >is not in the correct format.</exception>
    /// <exception cref="System.OverflowException" >s represents a number less than MinValue or greater than MaxValue.</exception>
    public static <#= Name #> Parse(string s)
<# if (TypeName == "string") { #>
        => new <#= Name #>(s);
<# } else { #>
        => new <#= Name #>(<#= TypeName #>.Parse(s));
<# } #>

    /// <summary>Converts the string representation of a number. A return value indicates whether the conversion succeeded.</summary>
    /// <returns>true if s was converted successfully; otherwise, false.</returns>
    public static bool TryParse(string s, out <#= Name #> result)
    {
<# if (TypeName == "string") { #>
        try
        {
            result = Parse(s);
            return true;
        }
        catch
        {
            result = NullValue;
            return false;
        }
<# } else { #>
        if(<#= TypeName #>.TryParse(s, out var r))
        {
            result = new <#= Name #>(r);
            return true;
        }
        else
        {
            result = NullValue;
            return false;
        }
<# } #>
    }
<# } else { #>
        // <#= Name #> is types that do not support Method Parse
        // <#= Name #> is types that do not support Method TryParse
<# } #>
<# } else { #>
        // No option specified
<# } #>


    //
    // Min, Max     // UnitGenerateOption.MinMaxMethod
    //
<# if (HasFlag(UnitGenerateOption.MinMaxMethod)) { #>

<# if (HasMinMaxMethod) { #>
    /// <summary>Min</summary>
    public static <#= Name #> Min(<#= Name #> x, <#= Name #> y)
        => x.HasValue && y.HasValue
           ? new <#= Name #>((<#= TypeName #>)Math.Max(x._value, y._value))
           : (x.IsUndef || y.IsUndef) ? UndefValue : NullValue;

    /// <summary>Max</summary>
    public static <#= Name #> Max(<#= Name #> x, <#= Name #> y)
        => x.HasValue && y.HasValue
           ? new <#= Name #>((<#= TypeName #>)Math.Max(x._value, y._value))
           : (x.IsUndef || y.IsUndef) ? UndefValue : NullValue;
<# } else { #>
        // <#= Name #> is types that do not support method Min
        // <#= Name #> is types that do not support method Max
<# } #>
<# } else { #>
        // No option specified
<# } #>


    //
    // TypeConverter
    //

    /// <summary>System.ComponentModel.TypeConverter</summary>
    public class <#= Name #>TypeConverter : System.ComponentModel.TypeConverter
    {
        private static readonly Type WrapperType = typeof(<#= Name #>);
        private static readonly Type ValueType = typeof(<#= TypeName #>);

        /// <summary>CanConvertFrom</summary>
        public override bool CanConvertFrom(System.ComponentModel.ITypeDescriptorContext? context, Type sourceType)
        {
            if (sourceType == WrapperType || sourceType == ValueType)
                return true;

            return base.CanConvertFrom(context, sourceType);
        }

        /// <summary>CanConvertTo</summary>
        public override bool CanConvertTo(System.ComponentModel.ITypeDescriptorContext? context, Type? destinationType)
        {
            if (destinationType == WrapperType || destinationType == ValueType)
                return true;

            return base.CanConvertTo(context, destinationType);
        }

        /// <summary>ConvertFrom</summary>
        public override object? ConvertFrom(System.ComponentModel.ITypeDescriptorContext? context, System.Globalization.CultureInfo? culture, object value)
        {
            if (value != null)
            {
                var t = value.GetType();

                if (t == typeof(<#= Name #>))
                    return (<#= Name #>)value;

                if (t == typeof(<#= TypeName #>))
                    return new <#= Name #>((<#= TypeName #>)value);

                return base.ConvertFrom(context, culture, value);
            }

            return <#= Name #>.NullValue;
        }

        /// <summary>ConvertTo</summary>
        public override object? ConvertTo(System.ComponentModel.ITypeDescriptorContext? context, System.Globalization.CultureInfo? culture, object? value, Type destinationType)
        {
            if (value is <#= Name #> wrappedValue)
            {
                if (destinationType == WrapperType)
                    return wrappedValue;

                if (destinationType == ValueType)
                    return wrappedValue.GetOr(null);
            }

            return base.ConvertTo(context, culture, value, destinationType);
        }
    }

<# if (HasFlag(UnitGenerateOption.JsonConverter)) { #>

    //
    // UnitGenerateOption.JsonConverter
    //

    /// <summary>JsonConverter</summary>
    public class <#= Name #>JsonConverter : JsonConverter<<#= Name #>>
    {
        /// <summary>HandleNull</summary>
        public override bool HandleNull
            => true;

        /// <summary>Write</summary>
        public override void Write(Utf8JsonWriter writer, <#= Name #> value, JsonSerializerOptions options)
        {
            // undefined; value.IsUndef の場合は null として出力

            var converter = options.GetConverter(typeof(<#= TypeNameNullable #>)) as JsonConverter<<#= TypeNameNullable #>>;
            if (converter is not null)
            {
                if (!value.IsUndef)
                    converter.Write(writer, (<#= TypeNameNullable #>)value.GetOr(null), options);
                else
                    converter.Write(writer, null, options);
            }
            else
                throw new JsonException($"{typeof(<#= TypeNameNullable #>)} converter does not found.");
        }

        /// <summary>Read</summary>
        public override <#= Name #> Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var converter = options.GetConverter(typeof(<#= TypeNameNullable #>)) as JsonConverter<<#= TypeNameNullable #>>;
            if (converter is not null)
            {
                return (reader.TokenType) switch
                {
                    JsonTokenType.Null => <#= Name #>.NullValue,
                    JsonTokenType.None => <#= Name #>.UndefValue,
                    _ => new <#= Name #>(converter.Read(ref reader, typeToConvert, options))
                };
            }
            else
                throw new JsonException($"{typeof(<#= TypeNameNullable #>)} converter does not found.");
        }
        
<#if (!IsArray) {  #>
        /// <summary>WriteAsPropertyName</summary>
        public override void WriteAsPropertyName(Utf8JsonWriter writer, <#= Name #> value, JsonSerializerOptions options)
        {
<#if (IsSupportUtf8Formatter()) {  #>
            Span<byte> buffer = stackalloc byte[36];
            if (System.Buffers.Text.Utf8Formatter.TryFormat(value._value, buffer, out var written))
                writer.WritePropertyName(buffer.Slice(0, written));
            else
                writer.WritePropertyName(value._value.ToString());
<# } else if (IsDateTime) { #>
            writer.WritePropertyName(value._value.ToString("yyyy-MM-dd"));
<# } else if (IsDateOnly) { #>
            writer.WritePropertyName(value._value.ToString("yyyy-MM-dd"));
<# } else if (IsTimeOnly) { #>
            writer.WritePropertyName(value._value.ToString("HH:mm:ss.FFFFFFF"));
<# } else if (IsUlid) { #>
            writer.WritePropertyName(value._value.ToString());
<# } else { #>
            writer.WritePropertyName(value._value.ToString());
<# } #>
        }

        /// <summary>ReadAsPropertyName</summary>
        public override <#= Name #> ReadAsPropertyName(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
<#if (IsSupportUtf8Formatter()) {  #>
            if (System.Buffers.Text.Utf8Parser.TryParse(reader.ValueSpan, out <#= TypeName #> value, out var consumed))
                return new <#= Name #>(value);
            else
                return new <#= Name #>(<#= TypeName #>.Parse(reader.GetString()));
<# } else if (IsDateOnly) { #>
            return new <#= Name #>(<#= TypeName #>.Parse(reader.GetString()));
<# } else if (IsTimeOnly) { #>
            return new <#= Name #>(<#= TypeName #>.Parse(reader.GetString()));
<# } else if (IsUlid) { #>
            return new <#= Name #>(<#= TypeName #>.Parse(reader.GetString()));
<# } else if(TypeName == "string")  { #>
            return new <#= Name #>(reader.GetString());
<# } else { #>
            return new <#= Name #>(<#= TypeName #>.Parse(reader.GetString()));
<# } #>
        }
<# } #>
    }

<# } #>
<# if (HasFlag(UnitGenerateOption.DapperTypeHandler)) { #>

#if !UGO_DAPPER_DISABLE
    //
    // UnitGenerateOption.DapperTypeHandler
    //

    /// <summary>Dapper.SqlMapper.TypeHandler</summary>
    public class <#= Name #>DapperTypeHandler : Dapper.SqlMapper.TypeHandler<<#= Name #>>
    {
        /// <summary>Parse</summary>
        public override <#= Name #> Parse(object value)
        {
            if (value is null)
                return new <#= Name #>((<#= TypeNameNullable #>)null);

<# if (TypeName == "string") { #>
            return new <#= Name #>((<#= TypeNameNullable #>)value);
<# } else if (IsArray) { #>
            return new <#= Name #>((<#= TypeNameNullable #>)value);
<# } else { #>
            return new <#= Name #>(<#= TypeName #>.Parse(value.ToString()));
<# } #>
       }
        //    => new <#= Name #>((<#= TypeNameNullable #>)value);

        /// <summary>SetValue</summary>
        public override void SetValue(System.Data.IDbDataParameter parameter, <#= Name #> value)
        {
            parameter.DbType = System.Data.DbType.<#= GetDbType() #>;
            parameter.Value = (<#= TypeNameNullable #>)value.GetOr(null);
        }
    }

    /// <summary>Dapper.SqlMapper.AddTypeHandler</summary>
    [ModuleInitializer]
    public static void <#= Name #>AddDapperTypeHandler()
        => Dapper.SqlMapper.AddTypeHandler(new <#= Name #>.<#= Name #>DapperTypeHandler());
#endif

<# } #>
<# if (HasFlag(UnitGenerateOption.EntityFrameworkValueConverter)) { #>

#if !UGO_ENTITYFRAMEWORK_DISABLE
    //
    // UnitGenerateOption.EntityFrameworkValueConverter
    //

    /// <summary>Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter</summary>
    public class <#= Name #>EntityFrameworkValueConverter : Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter<<#= Name #>, <#= TypeNameNullable #>>
    {
        /// <summary>ValueConverter</summary>
        public <#= Name #>EntityFrameworkValueConverter()
            : base(convertToProviderExpression: x => (<#= TypeNameNullable #>)x.GetOr(null),
                   convertFromProviderExpression: x => new <#= Name #>(x)) {}

        /// <summary>ValueConverter</summary>
        public <#= Name #>EntityFrameworkValueConverter(Microsoft.EntityFrameworkCore.Storage.ValueConversion.ConverterMappingHints mappingHints = null)
            : base(convertToProviderExpression: x => (<#= TypeNameNullable #>)x.GetOr(null),
                   convertFromProviderExpression: x => new <#= Name #>(x),
                   mappingHints: mappingHints) {}
    }
#endif

<# } #>
<# if (HasFlag(UnitGenerateOption.MessagePackFormatter)) { #>

#if !UGO_MESSAGEPACK_DISABLE
    //
    // UnitGenerateOption.MessagePackFormatter
    //

    /// <summary>IMessagePackFormatter</summary>
    private class <#= Name #>MessagePackFormatter : IMessagePackFormatter<<#= Name #>>
    {
        /// <summary>Serialize</summary>
        public void Serialize(ref MessagePackWriter writer, <#= Name #> value, MessagePackSerializerOptions options)
            => options.Resolver.GetFormatterWithVerify<<#= TypeName #>>().Serialize(ref writer, value._value, options);

        /// <summary>Deserialize</summary>
        public <#= Name #> Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
            => new <#= Name #>(options.Resolver.GetFormatterWithVerify<<#= TypeName #>>().Deserialize(ref reader, options));
    }
#endif

<# } #>

}
