<#@ template debug="false" hostspecific="false" language="C#" linePragmas="false" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY NullableUnitGenerator. DO NOT CHANGE IT.
// </auto-generated>
#pragma warning disable CS8669  // Null 許容参照型の注釈は、'#nullable' 注釈のコンテキスト内のコードでのみ使用する必要があります。自動生成されたコードには、ソースに明示的な '#nullable' ディレクティブが必要です。
#pragma warning disable CS8632	// '#nullable' 注釈コンテキスト内のコードでのみ、Null 許容参照型の注釈を使用する必要があります。
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
<# if (HasFlag(UnitGenerateOptions.DapperTypeHandler)) { #>
using System.Runtime.CompilerServices;
<# } #>
<# if (HasFlag(UnitGenerateOptions.JsonConverter)) { #>
using System.Text.Json;
using System.Text.Json.Serialization;
<# } #>
<# if (HasFlag(UnitGenerateOptions.MessagePackFormatter)) { #>
using MessagePack;
using MessagePack.Formatters;
<# } #>

using NullableUnitGenerator;

<# if (!string.IsNullOrEmpty(Namespace)) { #>
namespace <#= Namespace #>;
<# } #>


/// <summary>
/// <#= Name #> is TernaryType ValueObject<br/>
/// Primitive type is <#= TypeName #> (<#= TypeFullName #>)
/// </summary>
<# if (HasFlag(UnitGenerateOptions.MessagePackFormatter)) { #>
[MessagePackFormatter(typeof(<#= Name #>MessagePackFormatter))]
<# } #>
<# if (HasFlag(UnitGenerateOptions.JsonConverter)) { #>
[JsonConverter(typeof(<#= Name #>JsonConverter))]
<# } #>
[System.ComponentModel.TypeConverter(typeof(<#= Name #>TypeConverter))]
public readonly partial struct <#= Name #> : IEquatable<<#= Name #>>, IEqualityComparer<<#= Name #>> <#= HasFlag(UnitGenerateOptions.IComparable) && ContainsOperater("CompareTo") ? $", IComparable<{Name}>" : "" #>
{
    // TypeName : <#= TypeName #>
    // TypeFullName : <#= TypeFullName #>
    // <#= TypeName #> support method : <#= OperatorsString #>
    // IsArray : <#= IsArray #>
    // IsValueType : <#= IsValueType #>
    // UnitGenerateOptions : <#= Options #>
    // ToStringFormat : <#= ToStringFormat ?? "(null)" #>

    //
    // backing field
    //

    readonly <#= TypeName #> m_value = default;
    readonly UnitState m_state = UnitState.Undef;


    //
    // Constructor
    //

    /// <summary>Complete Constructor</summary>
    public <#= Name #>()
    { }

    /// <summary>Complete Constructor</summary>
    public <#= Name #>(in <#= Name #> value)
    {
        (m_state, m_value) = (value.m_state, value.m_value);

<# if (HasFlag(UnitGenerateOptions.Validate)) { #>
        // UnitGenerateOptions.Validate
        this.Validate();
<# } #>
    }

    /// <summary>Complete Constructor</summary>
    public <#= Name #>(in UnitState state, in <#= TypeName #> value = default)
    {
        (m_state, m_value) = (state, value) switch
        {
            (UnitState.Undef, _) => (state, default),
            (UnitState.Null, _) => (state, default),
<# if (!IsValueType) { #>
            (_, null) => (state, default),
<# } #>
            _ => (state, value)
        };

<# if (HasFlag(UnitGenerateOptions.Validate)) { #>
        // UnitGenerateOptions.Validate
        this.Validate();
<# } #>
    }

<# if (IsValueType) { #>
    /// <summary>Complete Constructor</summary>
    public <#= Name #>(in <#= TypeName #> value)
    {
        (m_state, m_value) = (UnitState.Value, value);

<# if (HasFlag(UnitGenerateOptions.Validate)) { #>
        // UnitGenerateOptions.Validate
        this.Validate();
<# } #>
    }
<# } #>

    /// <summary>Complete Constructor</summary>
    public <#= Name #>(in <#= TypeNameNullable #> value)
    {
        (m_state, m_value) = value switch
        {
            null => (UnitState.Null, default),
            _ => (UnitState.Value, (<#= TypeName #>)value),
        };

<# if (HasFlag(UnitGenerateOptions.Validate)) { #>
        // UnitGenerateOptions.Validate
        this.Validate();
<# } #>
    }


    //
    // static define
    //

    /// <summary>Display string as Undef.</summary>
    public static readonly string sUndef = $"~{UnitState.Undef}~";

    /// <summary>Display string as Null.</summary>
    public static readonly string sNull = $"~{UnitState.Null}~";

<#if (IsNumericType) { #>

    //
    // MaxValue, MinValue
    //

    /// <summary>Represents the largest possible value. This field is constant.</summary>
    public static readonly  <#= TypeName #> MaxValue = <#= TypeName #>.MaxValue;

    /// <summary>Represents the smallest possible value. This field is constant.</summary>
    public static readonly  <#= TypeName #> MinValue = <#= TypeName #>.MinValue;

<# } #>

    //
    // static property
    //

    /// <summary>Undefined value instance.</summary>
    public static <#= Name #> UndefValue { get; } = new(UnitState.Undef, default);

    /// <summary>Null value instance.</summary>
    public static <#= Name #> NullValue { get; } = new(UnitState.Null, default);

    /// <summary>Value state default value instance.</summary>
    public static <#= Name #> ValueStateDefaultValue { get; } = new(UnitState.Value, default);


    /// <summary>base type.</summary>
    static readonly Type BaseType = typeof(<#= TypeName #>);

    /// <summary>Get base type.</summary>
    public static Type GetBaseType() => BaseType;

    /// <summary>Is base type nullable?</summary>
    public static bool IsNullable { get; }
        = !BaseType.IsValueType                             // 値型でない -> Nullable
        || Nullable.GetUnderlyingType(BaseType) != null;    // 非Null許容型が取得できる -> Null許容演算子が指定されている -> Nullable


    //
    // static method
    //

    /// <summary>Determines if either value is undefined or null.</summary>
    /// <returns>
    /// Return Value – Description<br/>
    /// <b>UnitState.Undef</b> – if either value is undefined.<br/>
    /// <b>UnitState.Null</b> – if either value is null.<br/>
    /// <b>UnitState.Value</b> – if either value is set.
    /// </returns>
    public static UnitState CheckState(in <#= Name #> x, in <#= Name #> y, out <#= Name #> result)
    {
        var (state, outVal) = (x, y) switch
        {
            { x.IsUndef: true } => (UnitState.Undef, <#= Name #>.UndefValue),
            { y.IsUndef: true } => (UnitState.Undef, <#= Name #>.UndefValue),
            { x.IsNull: true } => (UnitState.Null, <#= Name #>.NullValue),
            { y.IsNull: true } => (UnitState.Null, <#= Name #>.NullValue),
            _ => (UnitState.Value, <#= Name #>.ValueStateDefaultValue),
        };
        result = outVal;
        return state;
    }

    /// <summary>Determine if a value is undefined or null.</summary>
    /// <returns>
    /// Return Value – Description<br/>
    /// <b>UnitState.Undef</b> – if value is undefined.<br/>
    /// <b>UnitState.Null</b> – if value is null.<br/>
    /// <b>UnitState.Value</b> – if value is set.
    /// </returns>
    public static UnitState CheckState(in <#= Name #> x, out <#= Name #> result)
    {
        var (state, outVal) = x switch
        {
            { IsUndef: true } => (UnitState.Undef, <#= Name #>.UndefValue),
            { IsNull: true } => (UnitState.Null, <#= Name #>.NullValue),
            _ => (UnitState.Value, <#= Name #>.ValueStateDefaultValue),
        };
        result = outVal;
        return state;
    }


    //
    // get state
    //

    /// <summary><see langword="true"/> if undefined; otherwise, <see langword="false"/>.</summary>
    /// <returns><b><see langword="true"/></b> : if undefined</returns>
    public bool IsUndef
        => m_state == UnitState.Undef;

    /// <summary><see langword="true"/> if null; otherwise, <see langword="false"/>.</summary>
    /// <returns><b><see langword="true"/></b> : if null</returns>
    public bool IsNull
        => m_state == UnitState.Null;

    /// <summary><see langword="true"/> if undefined or null; otherwise, <see langword="false"/>.</summary>
    /// <returns><b><see langword="true"/></b> : if null or undefined</returns>
    public bool IsUndefOrNull
        => m_state != UnitState.Value;

    /// <summary><see langword="true"/> if not undefined and not null; otherwise, <see langword="false"/>.</summary>
    /// <returns><b><see langword="true"/></b> : if not undefined and not null</returns>
    public bool HasValue
        => m_state == UnitState.Value;

    /// <summary>return value state.</summary>
    /// <returns>
    /// <b>Undef</b><br/>
    /// <b>Null</b><br/>
    /// <b>Value</b>
    /// </returns>
    public UnitState State
        => m_state;


    //
    // get value
    //

    /// <summary>return value if HasValue is true; otherwise, throw InvalidOperationException()</summary>
    /// <returns>
    /// <b>value</b> : if HasValue is true<br/>
    /// <b>throw InvalidOperationException("Value is Null.")</b> : if IsNull is true<br/>
    /// <b>throw InvalidOperationException("Value is Undef.")</b> : if IsUndef is true
    /// </returns>
    public <#= TypeName #> Value
        => GetOrThrow();

    /// <inheritdoc cref="Value" />
    public <#= TypeName #> AsPrimitive()
        => Value;

    /// <summary>return raw value</summary>
    /// <returns>inner raw value</returns>
    public <#= TypeName #>  GetRawValue()
        => m_value;

    /// <summary>return value if HasValue is true; otherwise, defaultValue</summary>
    /// <returns>
    /// <b>value</b> : if assigned and not null<br/>
    /// <b>defaultValue</b> : otherwise
    /// </returns>
    public <#= TypeName #> GetOr(in <#= TypeName #> defaultValue)
        => HasValue ? m_value : defaultValue;

<# if (IsValueType) { #>
    /// <inheritdoc cref="GetOr" />
    public <#= TypeNameNullable #> GetOr(in <#= TypeNameNullable #> defaultValue)
        => HasValue ? m_value : defaultValue;
<# } #>

    /// <summary>return value if HasValue is true; otherwise, <see langword="default"/></summary>
    /// <returns>
    /// <b>value</b> : if assigned and not null<br/>
    /// <b><see langword="default"/></b> : otherwise
    /// </returns>
    public <#= TypeName #> GetOrDefault()
        => GetOr(default);

    /// <summary>return value if HasValue is true; otherwise, <see langword="null"/></summary>
    /// <returns>
    /// <b>value</b> : if assigned and not null<br/>
    /// <b><see langword="null"/></b> : otherwise
    /// </returns>
    public <#= TypeNameNullable #> GetOrNull()
        => GetOr(null);

    /// <inheritdoc cref="Value" />
    public <#= TypeName #> GetOrThrow()
        => (m_state, m_value) switch
        {
            (UnitState.Value, _) => m_value,
            (UnitState.Null, _) => throw new InvalidOperationException($"Value is {UnitState.Null}."),
            _ => throw new InvalidOperationException($"Value is {UnitState.Undef}."),
        };

    /// <summary>return true and out parameter value if HasValue is true; otherwise, false.</summary>
    /// <param name="value">value</param>
    /// <param name="defaultValue">defaultValue</param>
    /// <returns><b><see langword="true"/> and out parameter value</b> : if HasValue is true,</returns>
    public bool TryGet(out <#= TypeName #> value, in <#= TypeName #> defaultValue = default)
    {
        value = HasValue ? m_value : defaultValue;
        return HasValue;
    }


    //
    // GetHashCode
    //

    /// <inheritdoc/>
    public override int GetHashCode()
        => (m_state, m_value).GetHashCode();

    /// <inheritdoc/>
    public int GetHashCode(<#= Name #> obj)
        => (obj.m_state, obj.m_value).GetHashCode();


    //
    // ToString
    //

    /// <summary>Returns this instance of System.String; no actual conversion is performed.</summary>
    /// <returns>The current string.</returns>
    public override string ToString()
<# if (ToStringFormat == null) { #>
        => HasValue ? $"{m_value}" : (IsNull ? sNull : sUndef);
<# } else { #>
        => HasValue ? string.Format("<#= ToStringFormat #>", m_value) : (IsNull ? sNull : sUndef);
<# } #>

    /// <summary>Returns this instance of System.String with the conversion specified by format.</summary>
    /// <returns>The specified string value.</returns>
    public string ToString(string format)
        => HasValue ? ((dynamic)m_value).ToString(format) : (IsNull ? sNull : sUndef);

<# if (HasFlag(UnitGenerateOptions.Validate)) { #>

    //
    // Validate    // UnitGenerateOptions.Validate
    //

    /// <summary>Validate</summary>
    private partial void Validate();

<# } #>

    //
    // implicit, explicit operator    // UnitGenerateOptions.ImplicitOperator or Unspecified
    //

<# if (HasFlag(UnitGenerateOptions.ImplicitOperator)) { #>
    /// <summary>implicit(暗黙的) operator</summary>
    public static implicit operator <#= TypeName #>(in <#= Name #> value)
        => (<#= TypeName #>)value.GetOrThrow();

    /// <summary>implicit(暗黙的) operator</summary>
    /// <returns><#= Name #> value.</returns>
    public static implicit operator <#= Name #>(in <#= TypeName #> value)
        => new(value);

<# if (IsValueType) { #>
    /// <summary>implicit(暗黙的) operator</summary>
    /// <returns><#= TypeNameNullable #> value.</returns>
    public static implicit operator <#= TypeNameNullable #>(in <#= Name #> value)
        => (<#= TypeNameNullable #>)value.GetOrNull();

    /// <summary>implicit(暗黙的) operator</summary>
    /// <returns><#= Name #> value.</returns>
    public static implicit operator <#= Name #>(in <#= TypeNameNullable #> value)
        => new(value);
<# } #>
<# } else { #>
    /// <summary>explicit(明示的) operator</summary>
    public static explicit operator <#= TypeName #>(in <#= Name #> value)
        => (<#= TypeName #>)value.GetOrThrow();

    /// <summary>explicit(明示的) operator</summary>
    /// <returns><#= Name #> value.</returns>
    public static explicit operator <#= Name #>(in <#= TypeName #> value)
        => new(value);

<# if (IsValueType) { #>
    /// <summary>explicit(明示的) operator</summary>
    /// <returns><#= TypeNameNullable #> value.</returns>
    public static explicit operator <#= TypeNameNullable #>(in <#= Name #> value)
        => (<#= TypeNameNullable #>)value.GetOrNull();

    /// <summary>explicit(明示的) operator</summary>
    /// <returns><#= Name #> value.</returns>
    public static explicit operator <#= Name #>(in <#= TypeNameNullable #> value)
        => new(value);
<# } #>
<# } #>


    //
    // Equals, IEquatable<<#= Name #>>
    //

    /// <inheritdoc/>
    public bool Equals(<#= Name #> other)
        => m_state.Equals(other.m_state) && m_value.Equals(other.m_value);

    /// <inheritdoc/>
    public bool Equals(<#= Name #> x, <#= Name #> y)
        => x.Equals(y);

    /// <inheritdoc/>
    public override bool Equals(object? obj)
        => obj is <#= Name #> ts && Equals(ts);


    //
    // ==, != operator
    //

    /// <summary>Returns a value indicating whether two instances are same value.</summary>
    /// <returns>true if other has the same value as this instance; otherwise, false.</returns>
    public static bool operator ==(in <#= Name #> x, in <#= Name #> y)
        => x.Equals(y);

    /// <summary>Returns a value indicates whether two instances are different values.</summary>
    /// <returns>true if other has the same value as this instance; otherwise, false.</returns>
    public static bool operator !=(in <#= Name #> x, in <#= Name #> y)
        => !(x == y);

<# if (HasFlag(UnitGenerateOptions.IComparable)) { #>

    //
    // CompareTo, IComparable<<#= Name #>>    // UnitGenerateOptions.IComparable
    //

<# if (ContainsOperater("CompareTo") || IsNumericType) { #>
    /// <summary>Compares this instance to a specified <#= Name #> and returns an indication of their relative values.</summary>
    /// <returns>
    /// A signed number indicating the relative values of this instance and value.<br/>
    /// <b>Return Value</b> – Description<br/>
    /// <b>Less than zero</b> – This instance is less than value.<br/>
    /// <b>Zero</b> – This instance is equal to value.<br/>
    /// <b>Greater than zero</b> – This instance is greater than value.
    /// </returns>
    public int CompareTo(<#= Name #> other)
        => HasValue && other.HasValue
           ? m_value.CompareTo(other.m_value)
           : 0;
<# } else { #>
    // <#= TypeName #> is types that do not support method CompareTo 
<# } #>

<# } #>
<# if (HasFlag(UnitGenerateOptions.ComparisonOperator)) { #>

    //
    // >, <, >=, <= operator    // UnitGenerateOptions.ComparisonOperator
    //

<# if (ContainsOperater("op_GreaterThan") || IsNumericType) { #>
    /// <summary>operator &gt; (GreaterThan)</summary>
    public static bool operator >(in <#= Name #> x, in <#= Name #> y)
        => x.HasValue && y.HasValue
           ? x.m_value > y.m_value
           : false;
<# } else { #>
    // <#= TypeName #> is types that do not support operater > (GreaterThan)
<# } #>

<# if (ContainsOperater("op_LessThan") || IsNumericType) { #>
    /// <summary>operator &lt; (LessThan)</summary>
    public static bool operator <(in <#= Name #> x, in <#= Name #> y)
        => x.HasValue && y.HasValue
           ? x.m_value < y.m_value
           : false;
<# } else { #>
    // <#= TypeName #> is types that do not support operater < (LessThan)
<# } #>

<# if (ContainsOperater("op_GreaterThanOrEqual") || IsNumericType) { #>
    /// <summary>operator &gt;= (GreaterThanOrEqual)</summary>
    public static bool operator >=(in <#= Name #> x, in <#= Name #> y)
        => x.HasValue && y.HasValue
           ? x.m_value >= y.m_value
           : false;
<# } else { #>
    // <#= TypeName #> is types that do not support operater >= (GreaterThanOrEqual)
<# } #>

<# if (ContainsOperater("op_LessThanOrEqual") || IsNumericType) { #>
    /// <summary>operator &lt;= (LessThanOrEqual)</summary>
    public static bool operator <=(in <#= Name #> x, in <#= Name #> y)
        => x.HasValue && y.HasValue
           ? x.m_value <= y.m_value
           : false;
<# } else { #>
    // <#= TypeName #> is types that do not support operater <= (LessThanOrEqual)
<# } #>

<# } #>
<# if (HasFlag(UnitGenerateOptions.ArithmeticOperator)) { #>

    //
    // +, -, *, /, % operator    UnitGenerateOptions.ArithmeticOperator
    //

<# if (ContainsOperater("op_Addition") || IsNumericType) { #>
    /// <summary>operator + (Addition)</summary>
    public static <#= Name #> operator +(in <#= Name #> x, in <#= Name #> y)
        => x.HasValue && y.HasValue
           ? new <#= Name #>(checked ((<#= TypeName #>)(x.m_value + y.m_value)))
           : (x.IsUndef || y.IsUndef) ? UndefValue : NullValue;
<# } else { #>
    // <#= TypeName #> is types that do not support operater + (Addition)
<# } #>

<# if (ContainsOperater("op_Subtraction") || IsNumericType) { #>
    /// <summary>operator - (Subtraction)</summary>
    public static <#= Name #> operator -(in <#= Name #> x, in <#= Name #> y)
        => x.HasValue && y.HasValue
           ? new <#= Name #>(checked ((<#= TypeName #>)(x.m_value - y.m_value)))
           : (x.IsUndef || y.IsUndef) ? UndefValue : NullValue;
<# } else { #>
    // <#= TypeName #> is types that do not support operater - (Subtraction)
<# } #>

<# if (ContainsOperater("op_Multiply") || IsNumericType) { #>
    /// <summary>operator * (Multiply)</summary>
    public static <#= Name #> operator *(in <#= Name #> x, in <#= Name #> y)
        => x.HasValue && y.HasValue
           ? new <#= Name #>(checked ((<#= TypeName #>)(x.m_value * y.m_value)))
           : (x.IsUndef || y.IsUndef) ? UndefValue : NullValue;
<# } else { #>
    // <#= TypeName #> is types that do not support operater * (Multiply)
<# } #>

<# if (ContainsOperater("op_Division") || IsNumericType) { #>
    /// <summary>operator / (Division)</summary>
    public static <#= Name #> operator /(in <#= Name #> x, in <#= Name #> y)
        => x.HasValue && y.HasValue
           ? new <#= Name #>(checked ((<#= TypeName #>)(x.m_value / y.m_value)))
           : (x.IsUndef || y.IsUndef) ? UndefValue : NullValue;
<# } else { #>
    // <#= TypeName #> is types that do not support operater / (Division)
<# } #>

<# if (ContainsOperater("op_Modulus") || IsNumericType) { #>
    /// <summary>operator % (Modulus)</summary>
    public static <#= Name #> operator %(in <#= Name #> x, in <#= Name #> y)
        => x.HasValue && y.HasValue
           ? new <#= Name #>(checked ((<#= TypeName #>)(x.m_value % y.m_value)))
           : (x.IsUndef || y.IsUndef) ? UndefValue : NullValue;
<# } else { #>
    // <#= TypeName #> is types that do not support operater % (Modulus)
<# } #>

<# } #>
<# if (HasFlag(UnitGenerateOptions.ValueArithmeticOperator)) { #>

    //
    // ++, --, +, -, *, /, % operator    UnitGenerateOptions.ValueArithmeticOperator
    //

<# if (ContainsOperater("op_Increment") || IsNumericType) { #>
    /// <summary>operator ++ (Increment)</summary>
    public static <#= Name #> operator ++(in <#= Name #> x)
        => x.HasValue
           ? new <#= Name #>(checked ((<#= TypeName #>)(x.m_value + 1)))
           : x.IsUndef ? UndefValue : NullValue;
<# } else { #>
    // <#= TypeName #> is types that do not support operater ++ (Increment)
<# } #>

<# if (ContainsOperater("op_Decrement") || IsNumericType) { #>
    /// <summary>operator -- (Decrement)</summary>
    public static <#= Name #> operator --(in <#= Name #> x)
        => x.HasValue
           ? new <#= Name #>(checked ((<#= TypeName #>)(x.m_value - 1)))
           : x.IsUndef ? UndefValue : NullValue;
<# } else { #>
    // <#= TypeName #> is types that do not support operater -- (Decrement)
<# } #>

<# if (ContainsOperater("op_Addition") || IsNumericType) { #>
    /// <summary>operator + (Addition)</summary>
    public static <#= Name #> operator +(in <#= Name #> x, in <#= TypeName #> y)
        => x.HasValue
           ? new <#= Name #>(checked ((<#= TypeName #>)(x.m_value + y)))
           : x.IsUndef ? UndefValue : NullValue;
<# } else { #>
    // <#= TypeName #> is types that do not support operater + (Addition)
<# } #>

<# if (ContainsOperater("op_Subtraction") || IsNumericType) { #>
    /// <summary>operator - (Subtraction)</summary>
    public static <#= Name #> operator -(in <#= Name #> x, in <#= TypeName #> y)
        => x.HasValue
           ? new <#= Name #>(checked ((<#= TypeName #>)(x.m_value - y)))
           : x.IsUndef ? UndefValue : NullValue;
<# } else { #>
    // <#= TypeName #> is types that do not support operater - (Subtraction)
<# } #>

<# if (ContainsOperater("op_Multiply") || IsNumericType) { #>
    /// <summary>operator * (Multiply)</summary>
    public static <#= Name #> operator *(in <#= Name #> x, in <#= TypeName #> y)
        => x.HasValue
           ? new <#= Name #>(checked ((<#= TypeName #>)(x.m_value * y)))
           : x.IsUndef ? UndefValue : NullValue;
<# } else { #>
    // <#= TypeName #> is types that do not support operater * (Multiply)
<# } #>

<# if (ContainsOperater("op_Division") || IsNumericType) { #>
    /// <summary>operator / (Division)</summary>
    public static <#= Name #> operator /(in <#= Name #> x, in <#= TypeName #> y)
        => x.HasValue
           ? new <#= Name #>(checked ((<#= TypeName #>)(x.m_value / y)))
           : x.IsUndef ? UndefValue : NullValue;
<# } else { #>
    // <#= TypeName #> is types that do not support operater / (Division)
<# } #>

<# if (ContainsOperater("op_Modulus") || IsNumericType) { #>
    /// <summary>operator % (Modulus)</summary>
    public static <#= Name #> operator %(in <#= Name #> x, in <#= TypeName #> y)
        => x.HasValue
           ? new <#= Name #>(checked ((<#= TypeName #>)(x.m_value % y)))
           : x.IsUndef ? UndefValue : NullValue;
<# } else { #>
    // <#= TypeName #> is types that do not support operater % (Modulus)
<# } #>

<# } #>
<# if (TypeName == "bool") { #>

    //
    // bool operator
    //

    /// <summary>operator true</summary>
    public static <#= TypeName #> operator true(<#= Name #> x)
        => x.HasValue
           ? x.m_value
           : x.IsUndef ? UndefValue : NullValue;

    /// <summary>operator false</summary>
    public static <#= TypeName #> operator false(<#= Name #> x)
        => x.HasValue
           ? !x.m_value
           : x.IsUndef ? UndefValue : NullValue;

    /// <summary>operator !</summary>
    public static <#= TypeName #> operator !(<#= Name #> x)
        => x.HasValue
           ? !x.m_value
           : x.IsUndef ? UndefValue : NullValue;

<# } #>
<# if (TypeName == "Guid" || TypeName == "System.Guid") { #>

    //
    // Guid
    //

    /// <summary>NewGuid</summary>
    /// <returns>Guid.NewGuid()</returns>
    public static <#= Name #> New()
        => new <#= Name #>(Guid.NewGuid());

    /// <inheritdoc cref="New()" />
    public static <#= Name #> New<#= Name #>()
        => new <#= Name #>(Guid.NewGuid());

<# } #>
<# if (TypeName == "Ulid" || TypeName == "System.Ulid") { #>

    //
    // Ulid
    //

    /// <summary>NewUlid</summary>
    /// <returns>Ulid.NewUlid()</returns>
    public static <#= Name #> New()
        => new <#= Name #>(Ulid.NewUlid());

    /// <inheritdoc cref="New()" />
    public static <#= Name #> New<#= Name #>()
        => new <#= Name #>(Ulid.NewUlid());

<# } #>
<# if (HasFlag(UnitGenerateOptions.ParseMethod)) { #>

    //
    // Parse, TryParse    // UnitGenerateOptions.ParseMethod
    //

<# if (ContainsOperater("Parse") || IsNumericType) { #>
    /// <summary>Converts the string representation of a number.</summary>
    /// <returns>A equivalent to the number contained in s.</returns>
    /// <exception cref="System.ArgumentNullException" >s is null.</exception>
    /// <exception cref="System.FormatException" >is not in the correct format.</exception>
    /// <exception cref="System.OverflowException" >s represents a number less than MinValue or greater than MaxValue.</exception>
    public static <#= Name #> Parse(string s)
<# if (TypeName == "string") { #>
        => new <#= Name #>(s);
<# } else { #>
        => new <#= Name #>(<#= TypeName #>.Parse(s));
<# } #>
<# } else { #>
    // <#= Name #> is types that do not support Method Parse
<# } #>

<# if (ContainsOperater("Parse") || IsNumericType) { #>
    /// <summary>Converts the string representation of a number. A return value indicates whether the conversion succeeded.</summary>
    /// <returns>true if s was converted successfully; otherwise, false.</returns>
    public static bool TryParse(string s, out <#= Name #> result)
    {
<# if (TypeName == "string") { #>
        try
        {
            result = Parse(s);
            return true;
        }
        catch
        {
            result = NullValue;
            return false;
        }
<# } else { #>
        if(<#= TypeName #>.TryParse(s, out var r))
        {
            result = new <#= Name #>(r);
            return true;
        }
        else
        {
            result = NullValue;
            return false;
        }
<# } #>
    }
<# } else { #>
    // <#= Name #> is types that do not support Method TryParse
<# } #>

<# } #>

<# if (HasFlag(UnitGenerateOptions.MinMaxMethod)) { #>

    //
    // Min, Max     // UnitGenerateOptions.MinMaxMethod
    //

<# if (ContainsOperater("Min") || IsNumericType) { #>
    /// <summary>Min</summary>
    public static <#= Name #> Min(<#= Name #> x, <#= Name #> y)
        => x.HasValue && y.HasValue
           ? new <#= Name #>(Math.Max(x.m_value, y.m_value))
           : (x.IsUndef || y.IsUndef) ? UndefValue : NullValue;
<# } else { #>
    // <#= Name #> is types that do not support method Min
<# } #>

<# if (ContainsOperater("Max") || IsNumericType) { #>
    /// <summary>Max</summary>
    public static <#= Name #> Max(<#= Name #> x, <#= Name #> y)
        => x.HasValue && y.HasValue
           ? new <#= Name #>(Math.Max(x.m_value, y.m_value))
           : (x.IsUndef || y.IsUndef) ? UndefValue : NullValue;
<# } else { #>
    // <#= Name #> is types that do not support method Max
<# } #>

<# } #>

    //
    // TypeConverter
    //

    /// <summary>System.ComponentModel.TypeConverter</summary>
    private class <#= Name #>TypeConverter : System.ComponentModel.TypeConverter
    {
        private static readonly Type WrapperType = typeof(<#= Name #>);
        private static readonly Type ValueType = typeof(<#= TypeName #>);

        /// <summary>CanConvertFrom</summary>
        public override bool CanConvertFrom(System.ComponentModel.ITypeDescriptorContext? context, Type sourceType)
        {
            if (sourceType == WrapperType || sourceType == ValueType)
            {
                return true;
            }

            return base.CanConvertFrom(context, sourceType);
        }

        /// <summary>CanConvertTo</summary>
        public override bool CanConvertTo(System.ComponentModel.ITypeDescriptorContext? context, Type? destinationType)
        {
            if (destinationType == WrapperType || destinationType == ValueType)
            {
                return true;
            }

            return base.CanConvertTo(context, destinationType);
        }

        /// <summary>ConvertFrom</summary>
        public override object? ConvertFrom(System.ComponentModel.ITypeDescriptorContext? context, System.Globalization.CultureInfo? culture, object value)
        {
            if (value != null)
            {
                var t = value.GetType();
                if (t == typeof(<#= Name #>))
                {
                    return (<#= Name #>)value;
                }
                if (t == typeof(<#= TypeName #>))
                {
                    return new <#= Name #>((<#= TypeName #>)value);
                }
            }
            else
            {
                return <#= Name #>.NullValue;
            }

            return base.ConvertFrom(context, culture, value);
        }

        /// <summary>ConvertTo</summary>
        public override object? ConvertTo(System.ComponentModel.ITypeDescriptorContext? context, System.Globalization.CultureInfo? culture, object? value, Type destinationType)
        {
            if (value is <#= Name #> wrappedValue)
            {
                if (destinationType == WrapperType)
                {
                    return wrappedValue;
                }

                if (destinationType == ValueType)
                {
                    return wrappedValue.GetOrNull();
                }
            }

            return base.ConvertTo(context, culture, value, destinationType);
        }
    }

<# if (HasFlag(UnitGenerateOptions.JsonConverter)) { #>

    //
    // UnitGenerateOptions.JsonConverter
    //

    /// <summary>JsonConverter</summary>
    private class <#= Name #>JsonConverter : JsonConverter<<#= Name #>>
    {
        /// <summary>HandleNull</summary>
        public override bool HandleNull
            => true;

        /// <summary>Write</summary>
        public override void Write(Utf8JsonWriter writer, <#= Name #> value, JsonSerializerOptions options)
        {
            // undefined; value.IsUndef の場合は null として出力

            var converter = options.GetConverter(typeof(<#= TypeNameNullable #>)) as JsonConverter<<#= TypeNameNullable #>>;
            if (converter is not null)
                converter.Write(writer, (<#= TypeNameNullable #>)value.GetOrNull(), options);
            else
                throw new JsonException($"{typeof(<#= TypeNameNullable #>)} converter does not found.");
        }

        /// <summary>Read</summary>
        public override <#= Name #> Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var converter = options.GetConverter(typeof(<#= TypeNameNullable #>)) as JsonConverter<<#= TypeNameNullable #>>;
            if (converter is not null)
            {
                var res = (reader.TokenType) switch
                {
                    JsonTokenType.Null => <#= Name #>.NullValue,
                    JsonTokenType.None => <#= Name #>.UndefValue,
                    _ => new <#= Name #>(converter.Read(ref reader, typeToConvert, options))
                };
                return res;
            }
            else
            {
                throw new JsonException($"{typeof(<#= TypeNameNullable #>)} converter does not found.");
            }
        }

<# if (HasFlag(UnitGenerateOptions.JsonConverterDictionaryKeySupport)) {  #>
        /// <summary>WriteAsPropertyName</summary>
        public override void WriteAsPropertyName(Utf8JsonWriter writer, <#= Name #> value, JsonSerializerOptions options)
        {
<#if (IsSupportUtf8Formatter()) {  #>
            Span<byte> buffer = stackalloc byte[36];
            if (System.Buffers.Text.Utf8Formatter.TryFormat(value.m_value, buffer, out var written))
            {
                writer.WritePropertyName(buffer.Slice(0, written));
            }
            else
            {
                writer.WritePropertyName(value.m_value.ToString());
            }
<# } else if (IsUlid) { #>
            writer.WritePropertyName(value.m_value.ToString());
<# } else { #>
            writer.WritePropertyName(value.m_value.ToString());
<# } #>
        }

        /// <summary>ReadAsPropertyName</summary>
        public override <#= Name #> ReadAsPropertyName(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
<#if (IsSupportUtf8Formatter()) {  #>
            if (System.Buffers.Text.Utf8Parser.TryParse(reader.ValueSpan, out <#= TypeName #> value, out var consumed))
            {
                return new <#= Name #>(value);
            }
            else
            {
                return new <#= Name #>(<#= TypeName #>.Parse(reader.GetString()));
            }
<# } else if (IsUlid) { #>
            return new <#= Name #>(<#= TypeName #>.Parse(reader.GetString()));
<# } else if(TypeName == "string")  { #>
            return new <#= Name #>(reader.GetString());
<# } else { #>
            return new <#= Name #>(<#= TypeName #>.Parse(reader.GetString()));
<# } #>
        }
<# } #>
    }

<# } #>
<# if (HasFlag(UnitGenerateOptions.DapperTypeHandler)) { #>

    //
    // UnitGenerateOptions.DapperTypeHandler
    //

    /// <summary>Dapper.SqlMapper.TypeHandler</summary>
    public class <#= Name #>TypeHandler : Dapper.SqlMapper.TypeHandler<<#= Name #>>
    {
        /// <summary>Parse</summary>
        public override <#= Name #> Parse(object value)
        {
            return new <#= Name #>((<#= TypeNameNullable #>)value);
        }

        /// <summary>SetValue</summary>
        public override void SetValue(System.Data.IDbDataParameter parameter, <#= Name #> value)
        {
            parameter.DbType = System.Data.DbType.<#= GetDbType() #>;
            parameter.Value = (<#= TypeNameNullable #>)value.GetOrNull();
        }
    }

    /// <summary>Dapper.SqlMapper.AddTypeHandler</summary>
    [ModuleInitializer]
    public static void AddTypeHandler()
    {
        Dapper.SqlMapper.AddTypeHandler(new <#= Name #>.<#= Name #>TypeHandler());
    }

<# } #>
<# if (HasFlag(UnitGenerateOptions.EntityFrameworkValueConverter)) { #>

    //
    // UnitGenerateOptions.EntityFrameworkValueConverter
    //

    /// <summary>Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter</summary>
    public class <#= Name #>ValueConverter : Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter<<#= Name #>, <#= TypeNameNullable #>>
    {
        /// <summary>ValueConverter</summary>
        public <#= Name #>ValueConverter()
            : base(
                    convertToProviderExpression: x => (<#= TypeNameNullable #>)x.GetOrNull(),
                    convertFromProviderExpression: x => new <#= Name #>(x))
        {
        }

        /// <summary>ValueConverter</summary>
        public <#= Name #>ValueConverter(Microsoft.EntityFrameworkCore.Storage.ValueConversion.ConverterMappingHints mappingHints = null)
            : base(
                    convertToProviderExpression: x => (<#= TypeNameNullable #>)x.GetOrNull(),
                    convertFromProviderExpression: x => new <#= Name #>(x),
                    mappingHints: mappingHints)
        {
        }
    }

<# } #>
<# if (HasFlag(UnitGenerateOptions.MessagePackFormatter)) { #>

    //
    // UnitGenerateOptions.MessagePackFormatter
    //

    /// <summary>IMessagePackFormatter</summary>
    private class <#= Name #>MessagePackFormatter : IMessagePackFormatter<<#= Name #>>
    {
        /// <summary>Serialize</summary>
        public void Serialize(ref MessagePackWriter writer, <#= Name #> value, MessagePackSerializerOptions options)
        {
            options.Resolver.GetFormatterWithVerify<<#= TypeName #>>().Serialize(ref writer, value.m_value, options);
        }

        /// <summary>Deserialize</summary>
        public <#= Name #> Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return new <#= Name #>(options.Resolver.GetFormatterWithVerify<<#= TypeName #>>().Deserialize(ref reader, options));
        }
    }

<# } #>

}
